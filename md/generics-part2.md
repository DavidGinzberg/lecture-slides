#Generics


-
### Reminder about subtypes

`B extends A`  
does **NOT** imply that  
`List<B> extends List<A>`

```Java
List<String> ls = new ArrayList<String>();
List<Object> lo = ls;
lo.add(new Object()); // Defeats the purpose of Generics

```

-
### Generic methods

Methods can be made generic independent of a generic class. eg:

```Java
static <T> T getMiddleElement(T[] arr){
  return arr[arr.length/2];
}
static <T> void setMiddleElement(T element, T[] arr){
  arr[arr.length/2] = element;
}
```

-
### Wildcards

We can also use wildcards instead of parameterized types

```Java
static void removeMiddle(List<?> list){
  list.remove(list.size()/2);
}
```

-
### Wildcards or type parameters?

When should we use one or the other?

- Wildcards - when the type you are working on is inconsequential to the task
- Type Parameters - when there is some relationship between the type and other variables or your return type.

-
-
### Bounding

```Java
static void addMessage(List<?> list){
  list.add("This Won't work and we'll get a weird error.");
}
```

This won't compile -- we can't guarantee that `list` can take a String. How do we fix this?

-
### Bounding

We can provide a lower bound that requires the wildcard to be something that can take a string.

```Java
static void addMessage(List<? super String> list){
  list.add("Bounding is helpful");
}
```

-
### Bounding works with Type Parameters too

- Type parameters only accept upper bounds (`<T extends Foo>`)


-
### Erasure

During compilation, the Java compiler erases type parameters and replaces them with their upper bound (or object). eg:

```Java
class Box<T>{
  public  T contents;
}
```
Becomes
```Java
class Box{
  public Object contents;
}
```

-

```Java
class Cage<T extends Animal>{
  public  T contents;
}
```
Becomes
```Java
class Cage{
  public Animal contents;
}
```

-
### Erasure consequences

- Erasures make it impossible to check parameterized instances 
  - (`myVar instanceof List<Foo>`) can't be checked
  - Can't check the runtime value of a type parameter
- Consequences with inheritance
  - Method signatures may break (Solved with Bridge methods)
- Can't overload methods based only on type parameters (`foo(List<String>)` and `foo(List<Integer>)` are considered the same method)


-
### Bridge methods

From [Updated Generics Tutorial](https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html)

```Java
public class Node<T> {

    public T data;

    public Node(T data) { this.data = data; }

    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

-
After type erasure (note `setData` methods):

```Java
public class Node {

    public Object data;

    public Node(Object data) { this.data = data; }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node {

    public MyNode(Integer data) { super(data); }
	 //Does not override Node.setData() !!!
    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

-
Compiler creates a new "Bridge method" to fix this problem

```Java
class MyNode extends Node {

    // Bridge method generated by the compiler
    //
    public void setData(Object data) {
        setData((Integer) data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}
```


-
-
### Resources

- [Updated Generics Tutorial](https://docs.oracle.com/javase/tutorial/java/generics/index.html)
- (Original) [Generics Tutorial](https://docs.oracle.com/javase/tutorial/extra/generics/index.html)